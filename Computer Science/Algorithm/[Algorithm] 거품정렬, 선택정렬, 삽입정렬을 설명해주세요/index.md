## 거품 정렬(Bubble Sort)

- 서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘

### Process(Ascending)

- 1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 세 번째 원소와 네 번째 원소를, … 이런 식으로 (마지막 - 1)번째 원소와 마지막 원소를 비교하여 조건에 맞지 않는다면 서로 교환합니다.
- 1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 원소까지는 정렬에서 제외됩니다. 이렇게 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어납니다.

### Java Code(Ascending)

```java
void bubbleSort(int[] arr) {
	int temp = 0;
	for (int i = 0; i < arr.length; i++) {
		for (int j = 1; j < arr.length - i; j++) {
			if (arr[j - 1] > arr[j]) {
				temp = arr[j - 1];
				arr[j - 1] = arr[j];
				arr[j] = temp;
			}
		}
 	}

	System.out.println(Arrays.toString(arr));
}
```

### GIF로 이해하는 Bubble Sort

[https://github.com/GimunLee/tech-refrigerator/blob/master/Algorithm/거품 정렬 (Bubble Sort).md#gif로-이해하는-bubble-sort](https://github.com/GimunLee/tech-refrigerator/blob/master/Algorithm/%EA%B1%B0%ED%92%88%20%EC%A0%95%EB%A0%AC%20(Bubble%20Sort).md#gif%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-bubble-sort)

### 시간복잡도

- (n - 1) + (n - 2) + (n - 3) + …. + 2 + 1 ⇒ n(n - 1) / 2이므로, O(n^2)입니다.
- Bubble Sort는 정렬이 되어있던 안 되어있던, 2개의 원소를 비교하기 때문에 최선, 평균, 푀악 모두 시간복잡도가 O(n^2)으로 동일합니다.

### 공간복잡도

- 주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 O(n)입니다.

### 장점

- 구현이 매우 간단하고, 소스코드가 직관적입니다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않습니다 → 제자리 정렬(in-place sorting)
- 안정 정렬(Stable Sort)입니다.

### 단점

- 시간복잡도가 최악, 최선, 평균 모두 O(n^2)으로, 굉장히 비효율적입니다.
- 정렬 되어있지 않은 원소가 정렬 되었을 때의 자리로 가기 위해서, 교환 연산(swap)이 많이 일어나게 됩니다.

<hr>  

## 선택 정렬(Selection Sort)

- 선택 정렬은 버블 정렬과 유사한 알고리즘으로, 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘입니다.
- 선택 정렬과 삽입 정렬이 헷갈릴 수 있는데, 선택 정렬은 배열에서 해당 자리를 선택하고 그 자리에 오는 값을 찾는 것이라고 생각하면 됩니다.

### Process(Ascending)

- 주어진 배열 중에 최소값을 찾습니다.
- 그 값을 맨 앞에 위치한 값과 교체합니다. (pass)
- 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체합니다.

### Java Code(Ascending)

```java
int[] arr = new int[]{41, 34, 6, 16, 38, 36, 28, 19, 45, 43, 49};

for (int i = 0; i < arr.length - 1; i++) {
    int min_index = i;

    for (int j = i + 1; j < arr.length; j++) {
        if (arr[j] < arr[min_index]) {
            min_index = j;
        }
    }

    int temp = arr[min_index];
    arr[min_index] = arr[i];
    arr[i] = temp;
}

System.out.println(Arrays.toString(arr));
```

- 우선, 위치(index)를 선택해줍니다.
- i + 1번째 원소부터 선택한 위치(index)의 값과 비교를 시작합니다.
- 오름차순이므로 현재 선택한 자리에 있는 갓보다 순회하고 있는 값이 작다면, 위치(index)를 갱신해줍니다.
- ‘2’번 반복문이 끝난 뒤에는 ‘min_index’에 ‘1번’에서 선택한 위치(index)에 들어가야하는 값의 위치(index)를 갖고 있으므로 서로 교환(swap)해줍니다.

### 시간복잡도

데이터의 개수가 n개라고 했을 때,

- 첫 번째 회전에서의 비교횟수: 1 ~ (n - 1) ⇒ n - 1
- 두 번째 회전에서의 비교횟수: 2 ~ (n - 1) ⇒ n - 2
- (n - 1) + (n - 2) + … + 2 + 1 ⇒ n(n - 1) / 2

비교하느 것이 상수 시간에 이루어진다는 가정 아래, n개의 주어진 배열을 정렬하는데 O(n^2) 만큼의 시간이 걸립니다. 최선, 평균, 최악의 경우 시간복잡도는 O(n^2)으로 동일합니다.

### 공간복잡도

주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 O(n)입니다.

### 장점

- 버블 정렬과 마찬가지로 알고리즘이 단순합니다.
- 정렬을 위한 비교 횟수는 많지만, 버블 정렬에 비해 실제로 교환하는 횟수는 적기 때문에 많은 교환이 일어나야 하는 자료상태에서 비교적 효율적입니다.
- 버블 정렬과 마찬가지로 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않습니다. ⇒ 제자리 정렬(in-place sort)

### 단점

- 시간복잡도가 O(n^2)으로, 비효율적입니다.
- 불안정 정렬(Unstable Sort)입니다.

### 불안정 정렬

예로들어 학생을 관리하고자 할 때, 성적순으로 나열하되, 성적이 같으면 이름을 기준으로 정렬하고 싶다고 할 때. 즉, 정렬 규칙이 다수이거나 특정 순서를 유지해야 할 때 문제가 될 수 있다.

**[(가영, 60), (가희, 60), (찬호, 70), (동우, 45)]** 이렇게 리스트가 존재한다고 생각해보자. 성적순이되, 성적이 같다면 이름순으로 정렬해야 한다고 했다.

그러면 보통 이름을 일단 정렬을 해놓을 것이다.

<이름 정렬 순>

[(가영, 60), (가희, 60), (동우, 45), (찬호, 70)]

그 다음에 '성적 순'으로 정렬 할 것이다. 만약 선택 정렬을 하면 어떻게 되는지 보자.

round 1 : [**(동우, 45)**, (가희, 60), **(가영, 60)**, (찬호, 70)]

round 2: [(동우, 45), **(가희, 60)**, (가영, 60), (찬호, 70)]

round 3: [(동우, 45), (가희, 60), **(가영, 60)**, (찬호, 70)]

이렇게 '가희'보다 '가영'이 앞에 있어야 함에도 순서가 바뀌어 버린 것을 볼 수 있다.  
  
<hr>  

## 삽입 정렬(Insertion Sort)

- 삽입 정렬은 현재 비교하고자 하는 타겟(target)과 그 이전의 원소들과 비교하며 자리를 교환(swap)하는 정렬 방법입니다.
- 삽입 정렬은 선택 정렬과 유사하지만, 좀 더 효율적인 정렬 알고리즘입니다.
- 삽입 정렬은 2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입하여 정렬하는 알고리즘입니다.
- 최선의 경우 O(n)이라는 엄청나게 빠른 효율성을 가지고 있어, 다른 정렬 알고리즘의 일부로 사용될 만큼 좋은 정렬 알고리즘입니다.

### Process(Ascending)

- 정렬은 2번째 위치(index)의 값을 temp에 저장합니다.
- temp와 이전에 있는 원소들과 비교하며 삽입해나갑니다.
- ‘1’번으로 돌아가 다음 위치(index)의 값을 temp에 저장하고, 반복합니다.

### Java Code(Ascending)

```java
int[] arr = new int[]{41, 34, 6, 16, 38, 36, 28, 19, 45, 43, 49};

for (int i = 1; i < arr.length; i++) {
    int temp = arr[i];
    int prev = i - 1;

    while (prev >= 0 && arr[prev] > temp) {
        arr[prev + 1] = arr[prev];
        prev--;
    }
    arr[prev + 1] = temp;
}

System.out.println(Arrays.toString(arr));
```

- 첫 번째 원소 앞(왼쪽)에는 어떤 원소도 갖고 있지 않기 때문에, 두 번째 위치(index)부터 탐색을 시작합니다. temp에 임시로 해당 위치(index)값을 저장하고, prev에는 해당 위치(index)의 이전 위치(index)를 저장합니다.
- 이전 위치(index)를 가리키는 prev가 음수가 되지 않고, 이전 위치(index)의 값이 ‘1’번에서 선택한 값보다 크면, 서로 값을 교환해주고 prev를 더 이전 위치(index)를 가리키도록 합니다.
- ‘2’번에서 반복문이 끝나고 난 뒤, prev에는 현재 temp 값보다 작은 값들 중 제일 큰 값의 위치(index)를 가리키게 됩니다. 따라서, (prev + 1)에 temp 값을 삽입해줍니다.

### 시간복잡도

- 최악의 경우(역으로 정렬되어 있을 경우) 선택 정려과 마찬가지로,
  (n - 1) + (n - 2) + … + 2 + 1 ⇒ n(n - 1) / 2 즉, O(n^2)입니다.
- 모두 정렬이 되어있는 경우(Optimal), 한 번씩 밖에 비교를 안 하므로 O(n)의 시간복잡도를 가지게 됩니다. 또한, 이미 정렬되어 있는 배열에 자료를 하나씩 삽입 / 제거하는 경우에는, 현실적으로 최고의 정렬 알고리즘이 되는데, 탐색을 제외한 오버헤드가 매우 적기 때문입니다.
- 최선의 경우는 O(n)의 시간복잡도를 갖고, 평균과 최악의 경우 O(n^2)의 시간복잡도를 갖게 됩니다.

### 공간복잡도

- 주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 O(n)입니다.

### 장점

- 알고리즘이 단순합니다.
- 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있습니다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않습니다. ⇒ 제자리 정렬(in-place sort)
- 안정 정렬(Stable Sort)입니다.
- 선택 정렬이나 버블 정렬과 같은 O(n^2) 알고리즘에 비교하여 상대적으로 빠릅니다.

### 단점

- 평균과 최악의 시간복잡도가 O(n^2)으로 비효율적입니다.
- 버블 정렬, 선택 정렬과 마찬가지로, 배열의 길이가 길어질수록 비효율적입니다.
